【ビット配置】
　__m256iは次のような配置である。x86はリトルエンディアンなので、AddressとBitPosが逆方向になっていることに注意せよ。

  Address [Bit] 0x00 0x01 ... 0xFE 0xFF
  Position[Bit] 0xFF 0xFE ... 0x01 0x00
  BitData       0/1  0/1  ... 0/1  0/1

　ただ、素では扱いにくいので、struct BitBoardでラップしている。その際、内部クラスでuint16_t line_[16]とunion関係にしている(暗黙に__m256iとキャスト可)。

  Address[Byte] 0x00      0x01      ... 0x1E      0x1F
  Position[Bit] 0xFF-0xF8 0xF7-0xF0 ... 0x0F-0x08 0x07-0x00
  line_[WORD]   <------ 0x00 ------>    <------ 0x0F ------>

　なお、_mm256_set_epi16におけるセット位置はPosition[Bit]基準である。したがって、_mm256_set_epi16(w0, w1, ..., w15)とすると、line_[0] = w15, line_[15] = w0となる。MSVCのデバッガにおける「m256i_i16」もline_と同じ基準で表示するので注意せよ。

【BitBoardとBoardとの関係】
　Board内部にはBitBoard型でblack_board_とwhite_board_が含まれている。石の置き場所全体は二つの論理和でいいし、置ける場所はそのビット反転で表せる。
　ただ、表現可能なのが256bitなのに盤面サイズは15x15なので話がややこしい。上記で言えばline_[0～14]しか使わず(line[15]は盤外)、また各line_も下位15bitしか使っていない。
　したがって「ある列が全て石で覆われた」⇔「line_[A]=0x7FFFu」となる。

　また、便宜上、盤面の左上を「0」、右上を「14」、右下を「255」と番号付けしている。このことから座標「X+15*Y(P)」(XもYも0～14)はkPositionArray[P]で表され、その内訳はline_[Y]に1 << Xを代入しただけのものである。
　ゆえに、kPositionArray[0]とは、「line_[0]だけ1」「__m256iの最下位ビットだけ1」である。

【各種ビット演算(等号編)】
　AND・OR・XORはそのまま置き換えればいいが、問題は等号である。
　_mm256_cmpeq_epi系列は「8～64bit毎の区切り(要素)で判定し、等しければその区間の全ビット1、そうでなければ全ビット0」と処理するので実はややこしい。具体的には、_mm256_movemask_epi8で「各バイトの最上位ビットを取り出し」てから、その値が0xFFFFFFFF(256/8=32バイトなので、全ビットが立った32bit整数を要求する)と等しいかを見る……といった処理になる。
　しかし、AVX2でより便利な手法が登場した。_mm256_testz_si256によって、「引数同士のAND演算結果が全て0なら1、そうでなければ0」を返せるようになったからだ。(_mm_testz_si128はSSE4)。つまり、_mm256_testz_si256(a, a)とした場合、aのビットが全て寝ていれば返り値1、そうでなければ0ということになる。ゆえに、比較したいaとbのXORを取ってからこれに掛ければ、「どこか等しくなければそのビットに1が立つ→それを検出すれば判定できる」わけである。
　なお、全ビットの論理反転は、とりあえず「全てのビットが立ったもの」とのXORを取っている。「」書きにしたのは、データ構造との兼ね合いもあって、実は_mm256_set1_epi16(0xFFFFu)ではなく_mm256_set_epi16(0x0000u, 0x7FFFu, ..., 0x7FFFu)としているからだ。

【各種ビット演算(シフト編)】
　まず左右シフト。例えば左シフトは_mm256_slli_epi16だがこれが盤面とどう対応するか。「左シフト」＝「各要素を左にシフト(最上位ビットを削り、下位ビットに0を付け足す)」ということなので、盤面で言えば「石を右に動かす」ことに相当する。要するに逆なのだ(コードではGetShiftPattern()で差異を吸収している)。
　また、先ほどの説明通り最上位ビットは使用していないので、ある行(line_)が「0x7FFF」であるものを「左シフト」しても、「0xFFFE」ではなく、「0x7FFE」となるようにしなければならない。したがって、使用可能な範囲を予めマスクとして用意し、シフト毎にAND演算で適用する必要があるのだ。
　更にややこしいのが上下シフト。まずバイト(8bit)単位でしか動かせないので、真上・真下ならまだしも斜めに動かすとなると「1バイトシフト→1ビットシフト」する必要がある。更に、__m256iは歴史上128bitづつ区切った運用もされていたことから、単純に_mm256_slli_si256でシフトすると、下位128bitの上位8bit(Position[Bit]で言えば0x7F-0x78)が失われてしまう。ぱっと思いつくのは一旦storeしてからloaduする(元が32bit境界だろうと、16bitズラせばアラインメント不整合になるのでloadではダメ)手段だが、「どう考えても遅すぎる」といった問題がある。
　そこで登場するのが_mm256_permute2x128_si256と_mm256_alignr_epi8。前者で2つの__m256iを128bitづつ切り貼りしてから、後者で「128bit抜き出す作業を2並列で」行います。例えば左シフトだと、_mm256_permute2x128_si256(board_, board_, _MM_SHUFFLE(0, 0, 2, 0))で次のようなデータを作成し、

  board_ A------AB------B
  ↓
  temp1  0------0A------A

次に_mm256_alignr_epi8(board_, temp1), 16 - 2)で切り貼りする。ぱっと見「右」にシフトしたように見えるが、Position基準ではちゃんと「左」にシフトしているので注意すること。

      line_[0]  ...  line_[15]
  board_ A------AB------B
  temp1  0------0a------a
  ↓
  temp2  0a-----aAB-----B
